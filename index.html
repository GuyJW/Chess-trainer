<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Chess Trainer v11</title>
  <style>
    :root{--bg:#0f1014;--panel:#151721;--panel2:#1b1f2b;--fg:#eef1ff;--fg2:#b9c1dd;--acc:#7aa2ff;--good:#58e06b;--warn:#ffd166;--bad:#ff6b6b;}
    html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;}
    #wrap{max-width:1240px;margin:0 auto;padding:12px;display:grid;grid-template-columns:minmax(320px,700px) 1fr;gap:12px}
    #left{display:flex;flex-direction:column;gap:10px}
    #boardWrap{background:var(--panel);border:1px solid #24283b;border-radius:10px;padding:10px;position:relative}
    #right{display:flex;flex-direction:column;gap:12px}
    canvas{width:100%;height:auto;border-radius:8px;background:#0e0f13;touch-action:none}
    #toolbar{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px;align-items:center}
    select,button,label{background:var(--panel2);color:var(--fg);border:1px solid #2a3147;border-radius:8px;padding:8px 10px}
    label{display:inline-flex;gap:6px;align-items:center}
    button:hover{filter:brightness(1.08);cursor:pointer}
    #legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    .pill{display:inline-flex;gap:6px;align-items:center;background:var(--panel2);border:1px solid #2a3147;border-radius:999px;padding:4px 8px;color:var(--fg2);font-size:12px}
    .dot{width:10px;height:10px;border-radius:50%}
    #opening{background:var(--panel);border:1px solid #24283b;border-radius:10px;padding:10px}
    #advice{background:var(--panel);border:1px solid #24283b;border-radius:10px;padding:10px;height:40vh;overflow:auto}
    #advice h3{margin:0 0 6px;color:var(--acc);font-size:14px}
    #glossary{background:var(--panel);border:1px solid #24283b;border-radius:10px;padding:10px}
    #glossary h4{margin:0 0 6px;color:var(--acc);font-size:14px}
    #savebar{display:flex;gap:8px;flex-wrap:wrap}
    #footer{opacity:.8;color:var(--fg2);font-size:12px;text-align:center;margin-top:8px}
    #captures{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .capBox{background:var(--panel);border:1px solid #24283b;border-radius:10px;padding:8px;min-height:42px}
    .capBox h4{margin:0 0 6px;font-size:12px;color:var(--fg2)}
    .capRow{font-size:20px;line-height:1.2;word-wrap:break-word}
    .switches{display:flex;gap:8px;flex-wrap:wrap}
    .switches label{border-radius:999px}
    @media (max-width:980px){#wrap{grid-template-columns:1fr} #advice{height:38vh}}
    /* Promotion modal */
    #modal{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:10}
    #modalInner{background:#0f111a;border:1px solid #283049;border-radius:10px;padding:14px;min-width:260px}
    #modalInner h3{margin:0 0 8px;font-size:16px}
    .promRow{display:flex;gap:10px}
    .promBtn{flex:1;border:1px solid #334; background:#151928;color:#fff;border-radius:8px;padding:12px;cursor:pointer;text-align:center}
    .promBtn:hover{filter:brightness(1.1)}
  </style>
</head>
<body>
<!-- v11 -->
<div id="wrap">
  <div id="left">
    <div id="toolbar">
      <label>Side
        <select id="sideSel"><option value="w">White</option><option value="b">Black</option></select>
      </label>
      <label>Difficulty (Elo)
        <select id="eloSel">
          <option>800</option><option>1200</option><option>1600</option>
          <option>2000</option><option>2400</option><option>2800</option>
        </select>
      </label>
      <button id="newBtn">New Game</button>
      <button id="undoBtn">Undo</button>
      <button id="hintBtn">Ask Advice</button>
      <button id="bestBtn">Play Best For Me</button>
    </div>
    <div class="switches" style="margin: -6px 0 0 0;">
      <label><input type="checkbox" id="tZones" checked/> Zones/Control</label>
      <label><input type="checkbox" id="tWeak" checked/> Weaknesses</label>
      <label><input type="checkbox" id="tFeed" checked/> Move feedback</label>
      <label><input type="checkbox" id="tRec" checked/> Show recommended move</label>
      <label><input type="checkbox" id="tPath" checked/> Show last move path</label>
    </div>
    <div id="boardWrap">
      <canvas id="board" width="700" height="700" aria-label="chess board"></canvas>
      <div id="legend">
        <span class="pill"><span class="dot" style="background:#3fbf5a"></span>Your strong control</span>
        <span class="pill"><span class="dot" style="background:#e05e05"></span>Enemy strong control</span>
        <span class="pill"><span class="dot" style="background:#e8c04c"></span>Critical/contested</span>
        <span class="pill"><span class="dot" style="background:#ffd400"></span>Recommended move</span>
      </div>
    </div>
    <div id="captures">
      <div class="capBox"><h4>Captured by White</h4><div id="capW" class="capRow"></div></div>
      <div class="capBox"><h4>Captured by Black</h4><div id="capB" class="capRow"></div></div>
    </div>
  </div>
  <div id="right">
    <div id="opening"><strong>Opening:</strong> —</div>
    <div id="advice">
      <h3>Chess Trainer — Advisory Feed</h3>
      <div id="feed"></div>
    </div>
    <div id="glossary">
      <h4>Quick Glossary</h4>
      <div style="font-size:13px;color:var(--fg2);line-height:1.35">
        <div><b>Center</b>: the d4/e4/d5/e5 squares—controlling them gives your pieces more options.</div>
        <div><b>Development</b>: bringing your pieces off the back rank to useful squares.</div>
        <div><b>King safety</b>: keeping your king protected (castling, shields of pawns).</div>
        <div><b>Inaccuracy</b>: a move that isn’t a blunder, but worse than strong alternatives.</div>
        <div><b>Blunder</b>: a move that loses material or allows a big tactic.</div>
        <div><b>Tempo</b>: a “turn”—losing tempi means giving the opponent time.</div>
      </div>
    </div>
    <div id="savebar">
      <button id="saveBtn">Save</button>
      <button id="loadBtn">Load</button>
      <button id="clearBtn">Clear Save</button>
    </div>
    <div id="footer">v11: robust first render; double-render on DOMContentLoaded & window load; context guard; minor tidy-ups.</div>
  </div>
</div>

<!-- Promotion Modal -->
<div id="modal">
  <div id="modalInner">
    <h3>Promote pawn to…</h3>
    <div class="promRow">
      <button class="promBtn" data-prom="q">♛ Queen</button>
      <button class="promBtn" data-prom="r">♜ Rook</button>
    </div>
    <div class="promRow" style="margin-top:8px">
      <button class="promBtn" data-prom="b">♝ Bishop</button>
      <button class="promBtn" data-prom="n">♞ Knight</button>
    </div>
  </div>
</div>

<script>
// ==============================
// v11 — render-first, safe init
// ==============================

// --- Utilities
const FR = sq => ({f: sq%8, r: (sq/8)|0});
const SQ = (f,r)=> r*8+f;
const inb = (f,r)=> f>=0 && f<8 && r>=0 && r<8;
const clone = x => JSON.parse(JSON.stringify(x));

function byId(id){ return document.getElementById(id); }

function pushFeed(msg, who="sys"){
  const el = byId('feed');
  if(!el) return;
  const time = new Date().toLocaleTimeString();
  const p=document.createElement('div');
  p.style.marginBottom='8px';
  p.innerHTML = `<span style="opacity:.7">${time}</span> — <strong>${who}:</strong> ${msg}`;
  el.appendChild(p); el.scrollTop = el.scrollHeight;
}
function setOpening(text){ const el=byId('opening'); if(el) el.innerHTML = '<strong>Opening:</strong> '+text; }
function sqName(sq){ const f="abcdefgh"[sq%8], r=((sq/8)|0)+1; return f+r; }
function pieceName(pc){ const n={p:"pawn",n:"knight",b:"bishop",r:"rook",q:"queen",k:"king"}; return n[pc.t]||pc.t; }

// --- Position
let S = {
  side:'w',
  board: new Array(64).fill(null),
  wk: SQ(4,0), bk: SQ(4,7),
  history: [],
  ply:0, fifty:0, full:1,
  lastMove: null,
  capW: [], capB: [],
  cr:{wk:true,wq:true,bk:true,bq:true},
  ep:-1
};
const back = "rnbqkbnr";
function pAt(sq){ return S.board[sq]; }
function put(sq, pc){ S.board[sq]=pc; if(pc && pc.t==='k'){ if(pc.c==='w') S.wk=sq; else S.bk=sq; } }
function newGame(){
  S.board.fill(null);
  for(let f=0; f<8; f++){ S.board[SQ(f,1)]={t:'p',c:'w'}; S.board[SQ(f,6)]={t:'p',c:'b'}; }
  for(let f=0; f<8; f++){ S.board[SQ(f,0)]={t:back[f],c:'w'}; S.board[SQ(f,7)]={t:back[f],c:'b'}; }
  S.wk = SQ(4,0); S.bk = SQ(4,7);
  S.side='w'; S.history=[]; S.ply=0; S.fifty=0; S.full=1; S.lastMove=null; S.capW=[]; S.capB=[];
  S.cr={wk:true,wq:true,bk:true,bq:true}; S.ep=-1;
  setOpening('—'); bookPlay = [];
  pushFeed("New game started. Your move.", "system");
  renderCaptures();
}

// --- Move generation (with castling & en passant)
const DIRS = {
  n:[[1,2],[2,1],[-1,2],[-2,1],[1,-2],[2,-1],[-1,-2],[-2,-1]],
  b:[[1,1],[-1,1],[1,-1],[-1,-1]],
  r:[[1,0],[-1,0],[0,1],[0,-1]],
  q:[[1,1],[-1,1],[1,-1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]]
};

function genMoves(color){
  const M=[];
  for(let from=0; from<64; from++){
    const pc=pAt(from); if(!pc || pc.c!==color) continue;
    const {f,r}=FR(from);
    if(pc.t==='p'){
      const dir = pc.c==='w'? 1:-1;
      const startRank = pc.c==='w'?1:6;
      const one = r+dir, two=r+2*dir;
      if(inb(f,one) && !pAt(SQ(f,one))){
        if(one===7 || one===0) ['q','r','b','n'].forEach(prom=>M.push({from,to:SQ(f,one),prom}));
        else M.push({from,to:SQ(f,one)});
        if(r===startRank && !pAt(SQ(f,two))) M.push({from,to:SQ(f,two)});
      }
      for(const df of [-1,1]){
        const cf=f+df, cr=r+dir; if(!inb(cf,cr)) continue;
        const t=pAt(SQ(cf,cr)); if(t && t.c!==pc.c){
          if(cr===7||cr===0) ['q','r','b','n'].forEach(prom=>M.push({from,to:SQ(cf,cr),prom}));
          else M.push({from,to:SQ(cf,cr)});
        }
      }
      if(S.ep!==-1){
        const ep=FR(S.ep);
        if(ep.r===r+dir && Math.abs(ep.f-f)===1) M.push({from,to:S.ep,ep:true});
      }
      continue;
    }
    if(pc.t==='n'){
      for(const [df,dr] of DIRS.n){
        const cf=f+df, cr=r+dr; if(!inb(cf,cr)) continue;
        const t=pAt(SQ(cf,cr)); if(!t || t.c!==pc.c) M.push({from,to:SQ(cf,cr)});
      }
      continue;
    }
    if(pc.t==='k'){
      for(const [df,dr] of DIRS.q){
        const cf=f+df, cr=r+dr; if(!inb(cf,cr)) continue;
        const t=pAt(SQ(cf,cr)); if(!t || t.c!==pc.c) M.push({from,to:SQ(cf,cr)});
      }
      if(!inCheck(color)){
        if(color==='w'){
          if(S.cr.wk && !pAt(SQ(5,0)) && !pAt(SQ(6,0)) && !attacked(SQ(5,0),'b') && !attacked(SQ(6,0),'b') && (pAt(SQ(7,0))?.t==='r') && pAt(SQ(7,0)).c==='w'){
            M.push({from,to:SQ(6,0),castle:'wk'});
          }
          if(S.cr.wq && !pAt(SQ(1,0)) && !pAt(SQ(2,0)) && !pAt(SQ(3,0)) && !attacked(SQ(2,0),'b') && !attacked(SQ(3,0),'b') && (pAt(SQ(0,0))?.t==='r') && pAt(SQ(0,0)).c==='w'){
            M.push({from,to:SQ(2,0),castle:'wq'});
          }
        } else {
          if(S.cr.bk && !pAt(SQ(5,7)) && !pAt(SQ(6,7)) && !attacked(SQ(5,7),'w') && !attacked(SQ(6,7),'w') && (pAt(SQ(7,7))?.t==='r') && pAt(SQ(7,7)).c==='b'){
            M.push({from,to:SQ(6,7),castle:'bk'});
          }
          if(S.cr.bq && !pAt(SQ(1,7)) && !pAt(SQ(2,7)) && !pAt(SQ(3,7)) && !attacked(SQ(2,7),'w') && !attacked(SQ(3,7),'w') && (pAt(SQ(0,7))?.t==='r') && pAt(SQ(0,7)).c==='b'){
            M.push({from,to:SQ(2,7),castle:'bq'});
          }
        }
      }
      continue;
    }
    const vecs = pc.t==='b'?DIRS.b : pc.t==='r'?DIRS.r : DIRS.q;
    for(const [df,dr] of vecs){
      let cf=f+df, cr=r+dr;
      while(inb(cf,cr)){
        const to=SQ(cf,cr), t=pAt(to);
        if(!t) M.push({from,to});
        else { if(t.c!==pc.c) M.push({from,to}); break; }
        cf+=df; cr+=dr;
      }
    }
  }
  return M.filter(m=> { const snap=make(m,true); const inCk=inCheck(color); unmake(snap); return !inCk; });
}

function inCheck(color){
  const kingSq = color==='w'? S.wk : S.bk;
  return attacked(kingSq, color==='w'?'b':'w');
}
function attacked(sq, byColor){
  for(let i=0;i<64;i++){
    const pc=pAt(i); if(!pc || pc.c!==byColor) continue;
    const {f,r}=FR(i);
    if(pc.t==='p'){
      const dir = pc.c==='w'?1:-1;
      for(const df of [-1,1]){ const cf=f+df, cr=r+dir; if(inb(cf,cr) && SQ(cf,cr)===sq) return true; }
    } else if(pc.t==='n'){
      for(const [df,dr] of DIRS.n){ const cf=f+df, cr=r+dr; if(inb(cf,cr) && SQ(cf,cr)===sq) return true; }
    } else if(pc.t==='k'){
      for(const [df,dr] of DIRS.q){ const cf=f+df, cr=r+dr; if(inb(cf,cr) && SQ(cf,cr)===sq) return true; }
    } else {
      const vecs = pc.t==='b'?DIRS.b : pc.t==='r'?DIRS.r : DIRS.q;
      for(const [df,dr] of vecs){
        let cf=f+df, cr=r+dr;
        while(inb(cf,cr)){
          const to=SQ(cf,cr); const t=pAt(to);
          if(to===sq) return true;
          if(t) break;
          cf+=df; cr+=dr;
        }
      }
    }
  }
  return false;
}

// --- Make/Unmake
function make(m, pseudo=false){
  const snap = {m, S: clone(S)};
  const pc = pAt(m.from);
  const tgt = pAt(m.to);
  if(!pseudo){ S.history.push(snap); }

  if(m.ep){
    const dir = pc.c==='w' ? -1 : 1;
    const capSq = m.to + 8*dir;
    if(pAt(capSq)){
      if(pc.c==='w') S.capW.push(pAt(capSq).t); else S.capB.push(pAt(capSq).t);
    }
    S.board[capSq]=null;
  }
  if(tgt){
    if(pc.c==='w') S.capW.push(tgt.t); else S.capB.push(tgt.t);
    if(!pseudo) renderCaptures();
  }
  put(m.to, m.prom? {t:m.prom, c:pc.c} : pc);
  put(m.from, null);
  if(pc.t==='k'){ if(pc.c==='w') S.wk=m.to; else S.bk=m.to; }

  if(m.castle){
    if(m.castle==='wk'){ put(SQ(5,0), pAt(SQ(7,0))); put(SQ(7,0), null); }
    if(m.castle==='wq'){ put(SQ(3,0), pAt(SQ(0,0))); put(SQ(0,0), null); }
    if(m.castle==='bk'){ put(SQ(5,7), pAt(SQ(7,7))); put(SQ(7,7), null); }
    if(m.castle==='bq'){ put(SQ(3,7), pAt(SQ(0,7))); put(SQ(0,7), null); }
  }

  if(pc.t==='k'){
    if(pc.c==='w'){ S.cr.wk=false; S.cr.wq=false; } else { S.cr.bk=false; S.cr.bq=false; }
  }
  if(pc.t==='r'){
    if(m.from===SQ(0,0)) S.cr.wq=false;
    if(m.from===SQ(7,0)) S.cr.wk=false;
    if(m.from===SQ(0,7)) S.cr.bq=false;
    if(m.from===SQ(7,7)) S.cr.bk=false;
  }
  if(tgt && tgt.t==='r'){
    if(m.to===SQ(0,0)) S.cr.wq=false;
    if(m.to===SQ(7,0)) S.cr.wk=false;
    if(m.to===SQ(0,7)) S.cr.bq=false;
    if(m.to===SQ(7,7)) S.cr.bk=false;
  }

  S.ep=-1;
  if(pc.t==='p' && Math.abs(FR(m.to).r - FR(m.from).r)===2){
    const dir = pc.c==='w'? 1 : -1;
    S.ep = m.from + 8*dir;
  }

  if(pc.t==='p'||tgt) S.fifty=0; else S.fifty++;
  S.side = (S.side==='w'?'b':'w');
  if(S.side==='w') S.full++;
  S.ply++; if(!pseudo) S.lastMove=m;
  return snap;
}
function unmake(snap){ S = snap.S; }

function isMateOrDraw(){
  const moves = genMoves(S.side);
  if(moves.length===0){ if(inCheck(S.side)) return S.side==='w'?'white_in_checkmate':'black_in_checkmate'; return 'stalemate'; }
  if(S.fifty>=100) return 'fiftymove';
  return null;
}

// --- Eval & Search (simple)
const VAL = {p:100, n:320, b:330, r:500, q:900, k:0};
function evaluate(){
  let score=0;
  for(let sq=0;sq<64;sq++){
    const pc=pAt(sq); if(!pc) continue;
    const v = VAL[pc.t]; score += (pc.c==='w'? v : -v);
  }
  return score;
}
function orderMoves(moves){
  return moves.sort((a,b)=> {
    const ta=pAt(a.to), tb=pAt(b.to);
    const ca = ta? VAL[ta.t] : 0;
    const cb = tb? VAL[tb.t] : 0;
    return cb - ca;
  });
}
function search(depth, alpha, beta){
  if(depth===0) return evaluate();
  let best=-1e9;
  const moves=orderMoves(genMoves(S.side));
  if(moves.length===0){ if(inCheck(S.side)) return -99999+(4-depth); return 0; }
  for(const m of moves){
    const snap=make(m,true);
    const sc = -search(depth-1,-beta,-alpha);
    unmake(snap);
    if(sc>best) best=sc;
    if(sc>alpha) alpha=sc;
    if(alpha>=beta) break;
  }
  return best;
}
function scoreMoveNegamax(m, depth){
  const snap=make(m,true);
  const score = -search(depth-1, -1e9, 1e9);
  unmake(snap);
  return score;
}
function bestMoveFor(){
  const elo = parseInt(document.getElementById('eloSel').value,10);
  let depth=2;
  if(elo<=900) depth=1; else if(elo<=1400) depth=2; else if(elo<=1800) depth=3;
  depth=Math.min(depth,3);
  let best=null, bestScore=-1e9;
  const moves=orderMoves(genMoves(S.side));
  for(const m of moves){
    const sc = scoreMoveNegamax(m, depth);
    if(sc>bestScore){ bestScore=sc; best=m; }
  }
  return {move:best, score:bestScore, depth};
}

// --- Openings (recognize a few)
const OPENINGS=[
  {name:"Queen's Gambit (D06–D69)", seq:["d2d4","d7d5","c2c4"],
   why:"White offers a wing pawn to deflect Black's central pawn and gain central space."},
  {name:"Dutch Defence (A80–A99)", seq:["d2d4","f7f5"],
   why:"Black fights for e4 immediately with ...f5, seeking kingside space."},
  {name:"Sicilian Defence (B20–B99)", seq:["e2e4","c7c5"],
   why:"Asymmetrical fight for the center with counterplay on the c-file."},
  {name:"French Defence (C00–C19)", seq:["e2e4","e7e6"],
   why:"Solid counterattack; Black prepares ...d5."},
  {name:"Ruy Lopez (C60–C99)", seq:["e2e4","e7e5","g1f3","b8c6","f1b5"],
   why:"Classic central pressure on e5/c6."}
];
let bookPlay=[];
function uciOfMove(m){ const a=FR(m.from), b=FR(m.to); return "abcdefgh"[a.f]+(a.r+1)+"abcdefgh"[b.f]+(b.r+1)+(m.prom? m.prom:""); }
function detectOpening(){
  const seq = bookPlay.join(',');
  for(const o of OPENINGS){
    const pre=o.seq.join(',');
    if(seq.startsWith(pre)){ setOpening(`${o.name}<br><small>${o.why}</small>`); return; }
  }
  if(bookPlay.length<=8) setOpening("Unclassified opening (line not detected yet).");
}

// --- UI / Drawing
let canvas, ctx;
const PAD=28;
let SIZE=700 - PAD - 6;
let TILE=SIZE/8;

function boardXY(f,r){ return {x: PAD + f*TILE, y: PAD + (7-r)*TILE}; }
function sqFromCanvas(x,y){
  const f = Math.floor((x - PAD)/TILE);
  const r = 7 - Math.floor((y - PAD)/TILE);
  if(f<0||f>7||r<0||r>7) return -1;
  return SQ(f,r);
}

function ensureCtx(){
  if(!canvas) canvas = byId('board');
  if(canvas && !ctx) ctx = canvas.getContext('2d');
  return !!(canvas && ctx);
}

function drawBoard(){
  if(!ensureCtx()) return;
  SIZE = canvas.width - PAD - 6;
  TILE = SIZE/8;

  ctx.clearRect(0,0,canvas.width,canvas.height);
  for(let r=0;r<8;r++){
    for(let f=0;f<8;f++){
      const light=((r+f)&1)===0;
      const {x,y}=boardXY(f,r);
      ctx.fillStyle=light? "#cdd5e5" : "#6b7a99";
      ctx.fillRect(x,y,TILE,TILE);
    }
  }

  for(let sq=0;sq<64;sq++){
    const pc=pAt(sq); if(!pc) continue;
    const {f,r}=FR(sq); const {x,y}=boardXY(f,r);
    drawPiece(pc, x+TILE/2, y+TILE/2);
  }

  ctx.fillStyle="#c9cfdf"; ctx.font="12px system-ui, sans-serif"; ctx.textAlign="center"; ctx.textBaseline="top";
  for(let f=0; f<8; f++){ const {x}=boardXY(f,0); ctx.fillText("abcdefgh"[f], x+TILE/2, PAD + 8 + 8 + SIZE); }
  ctx.textAlign="right"; ctx.textBaseline="middle";
  for(let r=0; r<8; r++){ const {y}=boardXY(0,r); ctx.fillText(String(r+1), PAD-6, y+TILE/2); }

  if(S.lastMove){
    const a=FR(S.lastMove.from), b=FR(S.lastMove.to);
    let pos=boardXY(a.f,a.r); ctx.fillStyle="rgba(122,162,255,0.18)"; ctx.fillRect(pos.x,pos.y,TILE,TILE);
    pos=boardXY(b.f,b.r); ctx.fillRect(pos.x,pos.y,TILE,TILE);
  }
}
function drawPiece(pc, cx, cy){
  const glyph={p:'♟',n:'♞',b:'♝',r:'♜',q:'♛',k:'♚'}[pc.t];
  ctx.font=`${TILE*0.8}px serif`; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillStyle="#111"; ctx.fillText(glyph, cx, cy);
  ctx.fillStyle=pc.c==='w'? "#fff":"#000"; ctx.fillText(glyph, cx-1, cy-1);
}

// --- Captures UI
function renderCaptures(){
  const mapGlyph = t => ({p:'♟',n:'♞',b:'♝',r:'♜',q:'♛',k:'♚'})[t] || '?';
  const w = S.capW.map(mapGlyph).join(' ');
  const b = S.capB.map(mapGlyph).join(' ');
  const wEl = byId('capW'), bEl = byId('capB');
  if(wEl) wEl.textContent = w;
  if(bEl) bEl.textContent = b;
}

// --- Input
let selSq=null, legalMoves=[]; let playerSide='w';
function onPointerDown(e){
  if(!ensureCtx()) return;
  const rect=canvas.getBoundingClientRect();
  const x=e.clientX-rect.left, y=e.clientY-rect.top;
  const sq = sqFromCanvas(x,y);
  if(sq===-1) return;
  if(selSq===null){
    const pc=pAt(sq);
    if(pc && pc.c===S.side && ((playerSide==='w' && S.side==='w') || (playerSide==='b' && S.side==='b'))){
      selSq=sq; legalMoves=genMoves(S.side).filter(m=>m.from===sq);
    }
  } else {
    const m=legalMoves.find(m=>m.to===sq);
    if(m){
      const pc=pAt(m.from);
      const destR = FR(m.to).r;
      if(pc.t==='p' && (destR===7 || destR===0) && !m.prom){
        showPromotion(choice=>{ m.prom=choice; doMove(m,true); });
      } else {
        doMove(m,true);
      }
      selSq=null; legalMoves=[];
    } else { selSq=null; legalMoves=[]; }
  }
  drawBoard();
}

function showPromotion(cb){
  const modal=byId('modal'); if(!modal) return cb('q');
  let promCB=cb; modal.style.display='flex';
  modal.querySelectorAll('.promBtn').forEach(btn=>{
    btn.onclick = ()=>{ const p=btn.getAttribute('data-prom'); modal.style.display='none'; promCB && promCB(p); promCB=null; };
  });
}

// --- Flow
function doMove(m, human=false){
  const snap=make(m,false);
  const uci=uciOfMove(m); bookPlay.push(uci); detectOpening();
  drawBoard();
  const result=isMateOrDraw(); if(result){ pushFeed("Result: "+result,"system"); return; }
  if((playerSide==='w' && S.side==='b') || (playerSide==='b' && S.side==='w')){ setTimeout(aiMove,120); }
}
function aiMove(){
  const best=bestMoveFor();
  if(!best.move){ const res=isMateOrDraw(); pushFeed("Game over: "+res,"system"); return; }
  const bm = best.move;
  const pc=pAt(bm.from);
  const destR=FR(bm.to).r;
  if(pc && pc.t==='p' && (destR===7 || destR===0) && !bm.prom) bm.prom='q';
  const uci=uciOfMove(bm); bookPlay.push(uci); detectOpening();
  make(bm,false); drawBoard();
}

function uciOfMove(m){ const a=FR(m.from), b=FR(m.to); return "abcdefgh"[a.f]+(a.r+1)+"abcdefgh"[b.f]+(b.r+1)+(m.prom? m.prom:""); }

// --- Init (robust)
function safeInit(){
  try{
    playerSide = (byId('sideSel')?.value) || 'w';
    canvas = byId('board');
    if(!canvas){
      // retry one microtask later (Safari sometimes late-parses)
      return queueMicrotask(safeInit);
    }
    ctx = canvas.getContext('2d');
    if(!ctx){
      // retry once more after next paint
      return requestAnimationFrame(safeInit);
    }
    // Wire events once
    canvas.addEventListener('pointerdown', onPointerDown, {passive:true});
    byId('newBtn')?.addEventListener('click', ()=>{ playerSide=byId('sideSel').value; newGame(); drawBoard(); if(playerSide==='b') aiMove(); });
    byId('undoBtn')?.addEventListener('click', ()=>{ if(!S.history.length) return; const snap=S.history.pop(); S=snap.S; renderCaptures(); drawBoard(); pushFeed("Undid last move.","system"); });
    byId('saveBtn')?.addEventListener('click', ()=>{ localStorage.setItem("chess_trainer_save", JSON.stringify(S)); pushFeed("Game saved locally on this device.","system"); });
    byId('loadBtn')?.addEventListener('click', ()=>{ const data=localStorage.getItem("chess_trainer_save"); if(!data){ pushFeed("No save found.","system"); return; } S=JSON.parse(data); renderCaptures(); drawBoard(); pushFeed("Game loaded.","system"); });
    byId('clearBtn')?.addEventListener('click', ()=>{ localStorage.removeItem("chess_trainer_save"); pushFeed("Save cleared.","system"); });
    byId('sideSel')?.addEventListener('change', e=>{ playerSide=e.target.value; });

    // Start
    newGame();
    drawBoard();
  }catch(err){
    console.error('Init error (v11):', err);
    setTimeout(safeInit, 50);
  }
}
document.addEventListener('DOMContentLoaded', ()=>{
  safeInit();
  // draw again after fonts/layout settle
  setTimeout(drawBoard, 50);
});
window.addEventListener('load', ()=>{
  drawBoard();
});
</script>
</body>
</html>
